"""
Быстрая сортировка
“Программирование это разбиение чего-то большого и невозможного на что-то маленькое и
вполне реальное”
Быстрая сортировка принадлежит такой стратегии, как “разделяй и властвуй”. Сначала
рассмотрим пример, затем напишем программный код
Два друга решили поиграть в игру: один загадывает число от 1 до 100, другой должен отгадать.
Согласитесь, что мы можем перебирать эти значения в случайном порядке, например: 32, 27, 60,
73… Да, мы можем угадать в какой-то момент, но что если мы обратиться к стратегии “разделяй
и властвуй” Обозначим друзей, друг_1 это Иван, который загадал число, друг_2 это Петр,
который отгадывает. Итак начнем:
Иван загадал число 77.
Петр: Число больше 50? Иван: Да.
Петр: Число больше 75? Иван: Да.
Петр: Число больше 87? Иван: Нет.
Петр: Число больше 81? Иван: Нет.
Петр: Число больше 78? Иван: Нет.
Петр: Число больше 76? Иван: Да
Число оказалось в диапазоне 76 < x < 78, значит это число 77. Задача решена. На самом деле мы
сейчас познакомились с алгоритмом бинарного поиска, который также принадлежит стратегии
“разделяй и властвуй”. Давайте перейдем к обсуждению программного кода быстрой
сортировки.
"""

def quicksort(array): #создаем функцию, в параметрах будем передавать массив array 
    if len(array) <= 1: # сразу делаем проверку, если длина массива меньше или равна 1, то мы возвращаем этот массив. Это базис рекурсии, место где рекурсия будет завершать работу.
        return array # Это базис рекурсии, место где рекурсия будет завершать работу.
    else: # а иначе мы будем выполнять действия
        pivot = array[0] # создаем перменную pivot, в которой будем сохранять наш первый элемент - array[0]
    # создаем два массива (в первый массив мы будем записывать все те числа, которые меньше нашего значения array[0], т.е. pivot; во второй массив мы будем класть все те значения, которые больше нашего элемента)
    less = [i for i in array[1:] if i <= pivot] # первый массив (воспользуемся генератором списков). Будем класть значение i проходясь по циклу for i in array, здесь мы не должны брать первый элемент, т.к. он уже известен, его взяли. Мы должны брать все элементы, rn после первого элемента (т.е. воспользуемся срезами списка), мы будем проходиться по всем элементам и добавлять только те, которые будут меньше либо равны нашей переменной pivot.  
    greater = [i for i in array[1:] if i > pivot] # создаем второй массив, где мы будем записывать элементы больше переменной pivot. Мы будем класть значение i проходясь по всему циклу, кроме первого элемента, будем класть элементы больше нашей переменной pivot.
    return quicksort(less) + [pivot] + quicksort(greater) # делаем return, dspsdftv следующую рекурсию. У нас есть переменная pivot и два списка: less и greater. Переменная pivot будет находиться посередине этих списков по значению. Но списки нужно отсортировать, для этого тоже вызываем функцию quicksort и будем сортировать наши значения. Переменную pivot преобразуем в список с помощью []. 
print(quicksort([10, 5, 2, 3]))

"""
Быстрая сортировка
● 1-е повторение рекурсии:
array = [10, 5, 2, 3]
pivot = 10
less = [5, 2, 3]
greater = []
return quicksort([5, 2, 3]) + [10] + quicksort([])
● 2-е повторение рекурсии:
array = [5, 2, 3]
pivot = 5
less = [2, 3]
greater = []
return quicksort([2, 3]) + [5] + quicksort([]) # Важно! Не забывайте, что здесь помимо вызова рекурсии
добавляется список [10]
● 3-е повторение рекурсии:
array = [2, 3]
return [2, 3] # Сработал базовый случай рекурсии
На этом работа рекурсии завершилась и итоговый список будет выглядеть таким образом: [2, 3] + [5] + [10] = [2, 3, 5,
10]
"""