"""
Быстрая сортировка
“Программирование это разбиение чего-то большого и невозможного на что-то маленькое и
вполне реальное”
Быстрая сортировка принадлежит такой стратегии, как “разделяй и властвуй”. Сначала
рассмотрим пример, затем напишем программный код
Два друга решили поиграть в игру: один загадывает число от 1 до 100, другой должен отгадать.
Согласитесь, что мы можем перебирать эти значения в случайном порядке, например: 32, 27, 60,
73… Да, мы можем угадать в какой-то момент, но что если мы обратиться к стратегии “разделяй
и властвуй” Обозначим друзей, друг_1 это Иван, который загадал число, друг_2 это Петр,
который отгадывает. Итак начнем:
Иван загадал число 77.
Петр: Число больше 50? Иван: Да.
Петр: Число больше 75? Иван: Да.
Петр: Число больше 87? Иван: Нет.
Петр: Число больше 81? Иван: Нет.
Петр: Число больше 78? Иван: Нет.
Петр: Число больше 76? Иван: Да
Число оказалось в диапазоне 76 < x < 78, значит это число 77. Задача решена. На самом деле мы
сейчас познакомились с алгоритмом бинарного поиска, который также принадлежит стратегии
“разделяй и властвуй”. Давайте перейдем к обсуждению программного кода быстрой
сортировки.
"""

def quicksort(array):
    if len(array) <= 1:
        return array
    else:
        pivot = array[0]
    less = [i for i in array[1:] if i <= pivot]
    greater = [i for i in array[1:] if i > pivot]
    return quicksort(less) + [pivot] + quicksort(greater)
print(quicksort([10, 5, 2, 3]))

"""
Быстрая сортировка
● 1-е повторение рекурсии:
array = [10, 5, 2, 3]
pivot = 10
less = [5, 2, 3]
greater = []
return quicksort([5, 2, 3]) + [10] + quicksort([])
● 2-е повторение рекурсии:
array = [5, 2, 3]
pivot = 5
less = [2, 3]
greater = []
return quicksort([2, 3]) + [5] + quicksort([]) # Важно! Не забывайте, что здесь помимо вызова рекурсии
добавляется список [10]
● 3-е повторение рекурсии:
array = [2, 3]
return [2, 3] # Сработал базовый случай рекурсии
На этом работа рекурсии завершилась и итоговый список будет выглядеть таким образом: [2, 3] + [5] + [10] = [2, 3, 5,
10]
"""